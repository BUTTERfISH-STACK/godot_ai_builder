@tool
extends Node

## Script Engine for Godot AI Builder
## ===================================
## Handles all script-related operations including creation, modification,
## compilation validation, and resource management.

# Signal declarations
signal script_created(script_path: String, script_data: Dictionary)
signal script_modified(script_path: String, modifications: Dictionary)
signal script_compiled(script_path: String, success: bool, error: Dictionary)
signal script_error(error: Dictionary)

# Script file extension
const SCRIPT_EXTENSION: String = ".gd"

# Maximum script size (1MB)
const MAX_SCRIPT_SIZE: int = 1048576

# Default scripts directory
const DEFAULT_SCRIPTS_PATH: String = "res://scripts"

# Reserved class names that cannot be used
const RESERVED_NAMES: Array[String] = [
	"Node", "Resource", "RefCounted", "Object",
	"Control", "Node2D", "Node3D", "Spatial", "Viewport",
	"Main", "Engine", "ClassDB", "ProjectSettings",
	"GDNativeLibrary", "GDNative", "NativeScript"
]

# Standard script template
const DEFAULT_SCRIPT_TEMPLATE: String = """extends {base_class}

## Auto-generated script
## Generated by Godot AI Builder

# Node references
@onready var _node: Node

func _ready() -> void:
	\"\"\"Called when the node enters the scene tree.\"\"\"
	pass

func _process(delta: float) -> void:
	\"\"\"Called every frame.\"\"\"
	pass

func _physics_process(delta: float) -> void:
	\"\"\"Called every physics frame.\"\"\"
	pass

# Add your custom methods here
"""


## Public Methods
## =============

func create_script(command: Dictionary) -> Dictionary:
	"""
	Creates a new GDScript file.
	
	Args:
		command: Dictionary containing:
			- path: String (required) - Path for the new script
			- name: String (required) - Script class name
			- code: String (optional) - Full script code
			- base_class: String (optional) - Class to extend
			- template: String (optional) - Template code to use
			- metadata: Dictionary (optional) - Additional metadata
	
	Returns:
		Dictionary with keys:
			- status: "success" | "error"
			- script_path: String (on success)
			- error: String (on error)
	"""
	var result: Dictionary = {
		"status": "error",
		"error": "",
		"timestamp": Time.get_unix_time_from_system()
	}
	
	# Extract parameters
	var path: String = command.get("path", "")
	var name: String = command.get("name", "")
	var code: String = command.get("code", "")
	var base_class: String = command.get("base_class", "Node")
	var template: String = command.get("template", "")
	var metadata: Dictionary = command.get("metadata", {})
	
	# Validate required fields
	if path.is_empty():
		result["error"] = "Script path is required"
		script_error.emit(result)
		return result
	
	if name.is_empty():
		result["error"] = "Script name is required"
		script_error.emit(result)
		return result
	
	# Validate class name
	var name_validation: Dictionary = _validate_class_name(name)
	if not name_validation.get("valid", false):
		result["error"] = name_validation.get("reason", "Invalid class name")
		script_error.emit(result)
		return result
	
	# Validate base class
	var base_validation: Dictionary = _validate_base_class(base_class)
	if not base_validation.get("valid", false):
		result["error"] = base_validation.get("reason", "Invalid base class")
		script_error.emit(result)
		return result
	
	# Ensure proper file extension
	if not path.ends_with(SCRIPT_EXTENSION):
		path += SCRIPT_EXTENSION
	
	# Ensure directory exists
	var dir_path: String = path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir_path):
		var dir: DirAccess = DirAccess.open(dir_path)
		if dir == null:
			result["error"] = "Failed to create directory: %s" % dir_path
			script_error.emit(result)
			return result
	
	# Generate code if not provided
	if code.is_empty():
		code = _generate_script_code(name, base_class, template)
	
	# Validate code size
	if code.length() > MAX_SCRIPT_SIZE:
		result["error"] = "Script exceeds maximum size of %d bytes" % MAX_SCRIPT_SIZE
		script_error.emit(result)
		return result
	
	# Validate code for dangerous patterns
	var code_validation: Dictionary = _validate_script_code(code)
	if not code_validation.get("valid", false):
		result["error"] = "Script contains invalid patterns: %s" % code_validation.get("reason", "")
		script_error.emit(result)
		return result
	
	# Write the script file
	var write_result: Dictionary = _write_script_file(path, code, metadata)
	if write_result.get("status") != "success":
		result["error"] = write_result.get("error", "Failed to write script")
		script_error.emit(result)
		return result
	
	# Validate compilation
	var compile_result: Dictionary = _validate_compilation(path, code)
	if not compile_result.get("success", false):
		result["error"] = "Script compilation failed: %s" % compile_result.get("error", "")
		result["error_details"] = compile_result
		script_error.emit(result)
		return result
	
	var script_path: String = path
	
	print("[Script Engine] Created script: %s" % script_path)
	
	# Emit signal
	var script_data: Dictionary = {
		"name": name,
		"path": script_path,
		"base_class": base_class,
		"code": code,
		"metadata": metadata
	}
	script_created.emit(script_path, script_data)
	
	result["status"] = "success"
	result["script_path"] = script_path
	result["script_name"] = name
	result["base_class"] = base_class
	
	return result


func modify_script(command: Dictionary) -> Dictionary:
	"""
	Modifies an existing script.
	
	Args:
		command: Dictionary containing:
			- path: String (required) - Path to the script
			- modifications: Dictionary (required) - Modifications to apply
			- replace_all: bool (optional) - Replace entire code vs patch
			- code: String (optional) - Complete replacement code
	
	Returns:
		Dictionary with keys:
			- status: "success" | "error"
			- script_path: String
			- modifications_applied: int
			- error: String (on error)
	"""
	var result: Dictionary = {
		"status": "error",
		"error": "",
		"timestamp": Time.get_unix_time_from_system()
	}
	
	# Extract parameters
	var path: String = command.get("path", "")
	var modifications: Dictionary = command.get("modifications", {})
	var replace_all: bool = command.get("replace_all", false)
	var code: String = command.get("code", "")
	
	# Validate required fields
	if path.is_empty():
		result["error"] = "Script path is required"
		script_error.emit(result)
		return result
	
	# Check if script exists
	if not FileAccess.file_exists(path):
		result["error"] = "Script not found: %s" % path
		script_error.emit(result)
		return result
	
	# Handle full replacement
	if replace_all and not code.is_empty():
		var write_result: Dictionary = _write_script_file(path, code, {})
		if write_result.get("status") != "success":
			result["error"] = write_result.get("error", "Failed to write script")
			script_error.emit(result)
			return result
		
		# Validate compilation
		var compile_result: Dictionary = _validate_compilation(path, code)
		if not compile_result.get("success", false):
			result["error"] = "Script compilation failed: %s" % compile_result.get("error", "")
			script_error.emit(result)
			return result
		
		print("[Script Engine] Replaced script: %s" % path)
		
		script_modified.emit(path, {"type": "replace_all"})
		
		result["status"] = "success"
		result["script_path"] = path
		result["modifications_applied"] = 1
		return result
	
	# Read existing script
	var read_result: Dictionary = _read_script_file(path)
	if read_result.get("status") != "success":
		result["error"] = read_result.get("error", "Failed to read script")
		script_error.emit(result)
		return result
	
	var current_code: String = read_result.get("code", "")
	var new_code: String = current_code
	
	# Apply modifications
	var modifications_applied: int = 0
	
	if modifications.has("extends"):
		# Change base class
		new_code = _change_extends(new_code, modifications["extends"])
		modifications_applied += 1
	
	if modifications.has("add_methods"):
		# Add new methods
		for method: Dictionary in modifications["add_methods"]:
			new_code = _add_method(new_code, method)
			modifications_applied += 1
	
	if modifications.has("modify_method"):
		# Modify existing method
		var method_result: String = _modify_method(new_code, modifications["modify_method"])
		if method_result != "":
			new_code = method_result
			modifications_applied += 1
	
	if modifications.has("add_variables"):
		# Add member variables
		for var_decl: String in modifications["add_variables"]:
			new_code = _add_variable(new_code, var_decl)
			modifications_applied += 1
	
	if modifications.has("add_constants"):
		# Add constants
		for constant: Dictionary in modifications["add_constants"]:
			new_code = _add_constant(new_code, constant)
			modifications_applied += 1
	
	if modifications.has("add_signals"):
		# Add signal declarations
		for signal_decl: Dictionary in modifications["add_signals"]:
			new_code = _add_signal_declaration(new_code, signal_decl)
			modifications_applied += 1
	
	if modifications.has("add_annotations"):
		# Add annotations
		for annotation: Dictionary in modifications["add_annotations"]:
			new_code = _add_annotation(new_code, annotation)
			modifications_applied += 1
	
	# Write modified script
	var write_result: Dictionary = _write_script_file(path, new_code, {})
	if write_result.get("status") != "success":
		result["error"] = write_result.get("error", "Failed to write script")
		script_error.emit(result)
		return result
	
	# Validate compilation
	var compile_result: Dictionary = _validate_compilation(path, new_code)
	if not compile_result.get("success", false):
		result["error"] = "Script compilation failed: %s" % compile_result.get("error", "")
		script_error.emit(result)
		return result
	
	print("[Script Engine] Modified script: %s (%d changes)" % [path, modifications_applied])
	
	script_modified.emit(path, {
		"modifications": modifications,
		"count": modifications_applied
	})
	
	result["status"] = "success"
	result["script_path"] = path
	result["modifications_applied"] = modifications_applied
	
	return result


func validate_script(command: Dictionary) -> Dictionary:
	"""
	Validates a script for compilation errors.
	
	Args:
		command: Dictionary containing:
			- path: String (optional) - Path to script file
			- code: String (optional) - Script code to validate
	
	Returns:
		Dictionary with keys:
			- valid: bool
			- error: String (if invalid)
			- error_details: Dictionary (on error)
	"""
	var result: Dictionary = {
		"valid": true,
		"error": "",
		"timestamp": Time.get_unix_time_from_system()
	}
	
	var path: String = command.get("path", "")
	var code: String = command.get("code", "")
	
	# Get code from file if path provided
	if path.is_empty() and code.is_empty():
		result["valid"] = false
		result["error"] = "Either path or code must be provided"
		return result
	
	if code.is_empty() and not path.is_empty():
		var read_result: Dictionary = _read_script_file(path)
		if read_result.get("status") != "success":
			result["valid"] = false
			result["error"] = read_result.get("error", "Failed to read script")
			return result
		code = read_result.get("code", "")
	
	# Validate syntax
	var validation: Dictionary = _validate_script_code(code)
	if not validation.get("valid", true):
		result["valid"] = false
		result["error"] = validation.get("reason", "Invalid syntax")
		return result
	
	# Validate compilation
	var compile_result: Dictionary = _validate_compilation(path, code)
	if not compile_result.get("success", false):
		result["valid"] = false
		result["error"] = compile_result.get("error", "Compilation failed")
		result["error_details"] = compile_result
		return result
	
	return result


func get_script_info(command: Dictionary) -> Dictionary:
	"""
	Returns information about a script.
	
	Args:
		command: Dictionary containing:
			- path: String (required) - Path to script file
	
	Returns:
		Dictionary with script information
	"""
	var result: Dictionary = {
		"status": "error",
		"error": "",
		"timestamp": Time.get_unix_time_from_system()
	}
	
	var path: String = command.get("path", "")
	
	if path.is_empty():
		result["error"] = "Script path is required"
		return result
	
	if not FileAccess.file_exists(path):
		result["error"] = "Script not found: %s" % path
		return result
	
	var read_result: Dictionary = _read_script_file(path)
	if read_result.get("status") != "success":
		result["error"] = read_result.get("error", "Failed to read script")
		return result
	
	var code: String = read_result.get("code", "")
	
	# Extract script information
	var script_info: Dictionary = {
		"path": path,
		"name": path.get_file().get_basename(),
		"size": code.length(),
		"lines": code.split("\n").size()
	}
	
	# Extract base class
	var extends_match: RegEx = RegEx.new()
	if extends_match.compile(r"^extends\\s+(\\w+)") == OK:
		var matches: Array[RegExMatch] = extends_match.search_all(code)
		if not matches.is_empty():
			script_info["base_class"] = matches[0].get_string(1)
	
	# Extract class name if specified
	var class_name_match: RegEx = RegEx.new()
	if class_name_match.compile(r"^class_name\\s+(\\w+)") == OK:
		var matches: Array[RegExMatch] = class_name_match.search_all(code)
		if not matches.is_empty():
			script_info["class_name"] = matches[0].get_string(1)
	
	# Extract methods
	script_info["methods"] = _extract_methods(code)
	
	# Extract member variables
	script_info["variables"] = _extract_variables(code)
	
	# Extract signals
	script_info["signals"] = _extract_signals(code)
	
	result["status"] = "success"
	result["script_info"] = script_info
	
	return result


## Internal Methods
## ==============

func _validate_class_name(name: String) -> Dictionary:
	"""
	Validates a script class name.
	"""
	var result: Dictionary = {"valid": true, "reason": ""}
	
	if name.is_empty():
		result["valid"] = false
		result["reason"] = "Class name cannot be empty"
		return result
	
	if not name.is_valid_identifier():
		result["valid"] = false
		result["reason"] = "Invalid identifier: %s" % name
		return result
	
	if name in RESERVED_NAMES:
		result["valid"] = false
		result["reason"] = "Reserved name: %s" % name
		return result
	
	# Check for numeric start
	if name[0].is_numeric():
		result["valid"] = false
		result["reason"] = "Class name cannot start with a number"
		return result
	
	return result


func _validate_base_class(base_class: String) -> Dictionary:
	"""
	Validates a base class for extension.
	"""
	var result: Dictionary = {"valid": true, "reason": ""}
	
	if base_class.is_empty():
		result["valid"] = false
		result["reason"] = "Base class cannot be empty"
		return result
	
	# Allow common base classes
	var allowed_bases: Array[String] = [
		"Node", "Node2D", "Node3D", "Control", "Spatial", "Viewport",
		"Resource", "RefCounted", "Object",
		"StaticBody3D", "RigidBody3D", "CharacterBody3D", "Area3D",
		"StaticBody2D", "RigidBody2D", "CharacterBody2D", "Area2D",
		"Camera3D", "Camera2D", "DirectionalLight3D", "Sprite2D",
		"MeshInstance3D", "CollisionShape3D", "CollisionShape2D",
		"Control", "Button", "Label", "Panel", "Window"
	]
	
	if not base_class in allowed_bases:
		# Check if class exists
		var class_exists: bool = ClassDB.class_exists(base_class)
		if not class_exists:
			result["valid"] = false
			result["reason"] = "Unknown base class: %s" % base_class
	
	return result


func _generate_script_code(name: String, base_class: String, template: String) -> String:
	"""
	Generates script code from template.
	"""
	if not template.is_empty():
		return template
	
	var code: String = DEFAULT_SCRIPT_TEMPLATE
	code = code.replace("{base_class}", base_class)
	code = code.replace("{name}", name)
	
	return code


func _validate_script_code(code: String) -> Dictionary:
	"""
	Validates script code for syntax and dangerous patterns.
	"""
	var result: Dictionary = {"valid": true, "reason": ""}
	
	if code.length() > MAX_SCRIPT_SIZE:
		result["valid"] = false
		result["reason"] = "Script exceeds maximum size"
		return result
	
	# Check for dangerous patterns
	var dangerous_patterns: Array[String] = [
		r"system\\s*\\(",
		r"popen\\s*\\(",
		r"exec\\s*\\(",
		r"eval\\s*\\("
	]
	
	for pattern: String in dangerous_patterns:
		var regex: RegEx = RegEx.new()
		if regex.compile(pattern) == OK:
			var matches: Array[RegExMatch] = regex.search_all(code)
			if not matches.is_empty():
				result["valid"] = false
				result["reason"] = "Dangerous pattern detected"
				return result
	
	# Check for proper indentation (basic check)
	var lines: Array[String] = code.split("\n")
	for i: int in range(lines.size()):
		var line: String = lines[i]
		# Skip empty lines and comments
		if line.strip_edges().is_empty() or line.strip_edges().begins_with("#"):
			continue
		
		# Check for tabs vs spaces (allow both but check consistency)
		if line.begins_with("\t") and line.count("\t") > 0:
			# Tab indentation found - this is acceptable
			pass
	
	return result


func _validate_compilation(path: String, code: String) -> Dictionary:
	"""
	Validates script compilation.
	"""
	var result: Dictionary = {
		"success": false,
		"error": "",
		"error_details": {}
	}
	
	# Create a temporary script to test compilation
	var temp_script: Script = GDScript.new()
	temp_script.source_code = code
	
	var error: Error = temp_script.reload()
	if error != OK:
		result["error"] = "Failed to reload script"
		result["error_details"]["error_code"] = error
		return result
	
	# Try to get compilation errors
	if temp_script.has_method("_get"):
		# Script has basic compilation capability
		pass
	
	# Check for syntax errors by attempting to parse
	var parse_result: Dictionary = _check_syntax(code)
	if not parse_result.get("valid", false):
		result["success"] = false
		result["error"] = parse_result.get("reason", "Syntax error")
		result["error_details"] = parse_result
		return result
	
	result["success"] = true
	return result


func _check_syntax(code: String) -> Dictionary:
	"""
	Checks GDScript syntax for obvious errors.
	"""
	var result: Dictionary = {"valid": true, "reason": ""}
	
	# Track brackets
	var paren_count: int = 0
	var brace_count: int = 0
	var bracket_count: int = 0
	
	var in_string: bool = false
	var string_char: String = ""
	var escape_next: bool = false
	
	for i: int in range(code.length()):
		var char: String = code[i]
		
		if escape_next:
			escape_next = false
			continue
		
		if in_string:
			if char == "\\":
				escape_next = true
			elif char == string_char:
				in_string = false
			continue
		
		if char == "\"" or char == "'":
			in_string = true
			string_char = char
			continue
		
		# Skip comments
		if code.substr(i, 2) == "//":
			while i < code.length() and code[i] != "\n":
				i += 1
			continue
		
		# Check multi-line comments
		if code.substr(i, 2) == "/*":
			var end_comment: int = code.find("*/", i + 2)
			if end_comment == -1:
				result["valid"] = false
				result["reason"] = "Unclosed multi-line comment"
				return result
			i = end_comment + 1
			continue
		
		# Count brackets
		match char:
			"(":
				paren_count += 1
			")":
				paren_count -= 1
				if paren_count < 0:
					result["valid"] = false
					result["reason"] = "Unmatched closing parenthesis at position %d" % i
					return result
			"{":
				brace_count += 1
			"}":
				brace_count -= 1
				if brace_count < 0:
					result["valid"] = false
					result["reason"] = "Unmatched closing brace at position %d" % i
					return result
			"[":
				bracket_count += 1
			"]":
				bracket_count -= 1
				if bracket_count < 0:
					result["valid"] = false
					result["reason"] = "Unmatched closing bracket at position %d" % i
					return result
	
	# Final balance check
	if paren_count != 0:
		result["valid"] = false
		result["reason"] = "Unmatched parentheses (count: %d)" % paren_count
	elif brace_count != 0:
		result["valid"] = false
		result["reason"] = "Unmatched braces (count: %d)" % brace_count
	elif bracket_count != 0:
		result["valid"] = false
		result["reason"] = "Unmatched brackets (count: %d)" % bracket_count
	
	return result


func _write_script_file(path: String, code: String, metadata: Dictionary) -> Dictionary:
	"""
	Writes a script file to disk.
	"""
	var result: Dictionary = {"status": "error", "error": ""}
	
	var file: FileAccess = FileAccess.open(path, FileAccess.WRITE)
	if file == null:
		result["error"] = "Failed to open file for writing: %s" % path
		return result
	
	file.store_string(code)
	
	# Add metadata as comment at the top if provided
	if not metadata.is_empty():
		var meta_str: String = "\n# Metadata: " + JSON.stringify(metadata)
		file.store_string(meta_str)
	
	file.close()
	
	result["status"] = "success"
	result["path"] = path
	result["size"] = code.length()
	
	return result


func _read_script_file(path: String) -> Dictionary:
	"""
	Reads a script file from disk.
	"""
	var result: Dictionary = {"status": "error", "error": ""}
	
	if not FileAccess.file_exists(path):
		result["error"] = "File not found: %s" % path
		return result
	
	var file: FileAccess = FileAccess.open(path, FileAccess.READ)
	if file == null:
		result["error"] = "Failed to open file for reading: %s" % path
		return result
	
	var code: String = file.get_as_text()
	file.close()
	
	result["status"] = "success"
	result["path"] = path
	result["code"] = code
	result["size"] = code.length()
	
	return result


func _change_extends(code: String, new_base: String) -> String:
	"""
	Changes the extends clause of a script.
	"""
	var lines: Array[String] = code.split("\n")
	var new_lines: Array[String] = []
	var found_extends: bool = false
	
	for line: String in lines:
		var stripped: String = line.strip_edges()
		
		if stripped.begins_with("extends") and not found_extends:
			new_lines.append("extends %s" % new_base)
			found_extends = true
		else:
			new_lines.append(line)
	
	# If no extends found, add it at the beginning
	if not found_extends:
		new_lines.insert(0, "extends %s" % new_base)
	
	return "\n".join(new_lines)


func _add_method(code: String, method: Dictionary) -> String:
	"""
	Adds a new method to a script.
	"""
	var method_name: String = method.get("name", "new_method")
	var return_type: String = method.get("return_type", "void")
	var params: Array = method.get("parameters", [])
	var body: String = method.get("body", "\tpass")
	
	var new_method: String = "\nfunc %s(%s) -> %s:\n%s" % [
		method_name,
		", ".join(params),
		return_type,
		body
	]
	
	# Find the end of the class and insert before it
	var lines: Array[String] = code.split("\n")
	var insert_pos: int = lines.size()
	
	# Find last brace
	for i: int in range(lines.size() - 1, -1, -1):
		if lines[i].strip_edges() == "}":
			insert_pos = i
			break
	
	lines.insert(insert_pos, new_method)
	return "\n".join(lines)


func _modify_method(code: String, modification: Dictionary) -> String:
	"""
	Modifies an existing method in a script.
	"""
	var method_name: String = modification.get("name", "")
	var new_body: String = modification.get("body", "")
	
	if method_name.is_empty() or new_body.is_empty():
		return ""
	
	# Use regex to find and replace the method
	var pattern: String = "func\\s+%s\\s*\\([^)]*\\)\\s*->?\\s*\\w+:\\s*([\\s\\S]*?)(?=\\n\\s*func|\\n\\s*#|\\n\\s*@|\\n\\s*$)"
	var regex: RegEx = RegEx.new()
	if regex.compile(pattern) != OK:
		return ""
	
	var new_code: String = regex.sub(code, "func %s() -> void:\n\t%s\n" % [method_name, new_body], true)
	
	return new_code


func _add_variable(code: String, var_decl: String) -> String:
	"""
	Adds a member variable to a script.
	"""
	var lines: Array[String] = code.split("\n")
	var insert_pos: int = 0
	
	# Find end of variable declarations section (after @export, etc.)
	for i: int in range(lines.size()):
		var line: String = lines[i].strip_edges()
		if line.begins_with("func ") or line.begins_with("@onready") or line.begins_with("signal ") or line.is_empty():
			insert_pos = i
			break
	
	var var_line: String = "\tvar %s" % var_decl
	lines.insert(insert_pos, var_line)
	
	return "\n".join(lines)


func _add_constant(code: String, constant: Dictionary) -> String:
	"""
	Adds a constant to a script.
	"""
	var const_name: String = constant.get("name", "CONST")
	var value: Variant = constant.get("value", 0)
	
	var lines: Array[String] = code.split("\n")
	var insert_pos: int = 0
	
	for i: int in range(lines.size()):
		var line: String = lines[i].strip_edges()
		if line.begins_with("func ") or line.begins_with("@onready") or line.begins_with("var "):
			insert_pos = i
			break
	
	var const_line: String = "\tconst %s = %s" % [const_name, str(value)]
	lines.insert(insert_pos, const_line)
	
	return "\n".join(lines)


func _add_signal_declaration(code: String, signal_decl: Dictionary) -> String:
	"""
	Adds a signal declaration to a script.
	"""
	var signal_name: String = signal_decl.get("name", "my_signal")
	var params: Array = signal_decl.get("parameters", [])
	
	var lines: Array[String] = code.split("\n")
	var insert_pos: int = 0
	
	for i: int in range(lines.size()):
		var line: String = lines[i].strip_edges()
		if line.begins_with("func "):
			insert_pos = i
			break
	
	var param_str: String = ""
	if not params.is_empty():
		param_str = "(" + ", ".join(params) + ")"
	
	var signal_line: String = "\tsignal %s%s" % [signal_name, param_str]
	lines.insert(insert_pos, signal_line)
	
	return "\n".join(lines)


func _add_annotation(code: String, annotation: Dictionary) -> String:
	"""
	Adds an annotation to the script.
	"""
	var annot_type: String = annotation.get("type", "export")
	var annot_value: Variant = annotation.get("value", "")
	
	var lines: Array[String] = code.split("\n")
	var insert_pos: int = 0
	
	for i: int in range(lines.size()):
		var line: String = lines[i].strip_edges()
		if line.begins_with("extends") or line.begins_with("class_name"):
			insert_pos = i + 1
			break
	
	var annot_str: String = "@%s" % annot_type
	if not str(annot_value).is_empty():
		annot_str += '("%s")' % str(annot_value)
	
	lines.insert(insert_pos, annot_str)
	
	return "\n".join(lines)


func _extract_methods(code: String) -> Array:
	"""
	Extracts method definitions from script code.
	"""
	var methods: Array = []
	
	var func_regex: RegEx = RegEx.new()
	if func_regex.compile(r"func\\s+(\\w+)\\s*\\([^)]*\\)") != OK:
		return methods
	
	var matches: Array[RegExMatch] = func_regex.search_all(code)
	for match: RegExMatch in matches:
		methods.append(match.get_string(1))
	
	return methods


func _extract_variables(code: String) -> Array:
	"""
	Extracts variable definitions from script code.
	"""
	var variables: Array = []
	
	var var_regex: RegEx = RegEx.new()
	if var_regex.compile(r"var\\s+(\\w+)") != OK:
		return variables
	
	var matches: Array[RegExMatch] = var_regex.search_all(code)
	for match: RegExMatch in matches:
		variables.append(match.get_string(1))
	
	return variables


func _extract_signals(code: String) -> Array:
	"""
	Extracts signal definitions from script code.
	"""
	var signals: Array = []
	
	var signal_regex: RegEx = RegEx.new()
	if signal_regex.compile(r"signal\\s+(\\w+)") != OK:
		return signals
	
	var matches: Array[RegExMatch] = signal_regex.search_all(code)
	for match: RegExMatch in matches:
		signals.append(match.get_string(1))
	
	return signals
